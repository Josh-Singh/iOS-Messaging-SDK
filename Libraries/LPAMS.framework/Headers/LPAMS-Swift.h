// Generated by Apple Swift version 3.0 (swiftlang-800.0.46.2 clang-800.0.38)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import LPInfra;
@import Foundation;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"

SWIFT_CLASS("_TtC5LPAMS22AMSConversationHandler")
@interface AMSConversationHandler : NSObject <GeneralManagerProtocol>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) AMSConversationHandler * _Nonnull instance;)
+ (AMSConversationHandler * _Nonnull)instance;
/**
  Send/Publish all pending message for conversation<br/>
  Pending messages are messages that waiting to be sent after the conversation is open
*/
- (void)sendPendingMessages:(LPConversationEntity * _Nonnull)conversation;
- (void)clearManager;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface AMSConversationHandler (SWIFT_EXTENSION(LPAMS))
@end


@interface AMSConversationHandler (SWIFT_EXTENSION(LPAMS))
@end


@interface AMSConversationHandler (SWIFT_EXTENSION(LPAMS))
@end


@interface AMSConversationHandler (SWIFT_EXTENSION(LPAMS))
@end


@interface AMSConversationHandler (SWIFT_EXTENSION(LPAMS))
@end

@protocol ConversationParamProtocol;
@protocol AMSManagerDelegate;
@class NSError;
@class CSATModel;

SWIFT_CLASS("_TtC5LPAMS10AMSManager")
@interface AMSManager : BaseConversationManager <GeneralManagerProtocol>
@property (nonatomic, weak) id <AMSManagerDelegate> _Nullable managerDelegate;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) AMSManager * _Nonnull instance;)
+ (AMSManager * _Nonnull)instance;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/**
  Perform connect to socket for conversationQuery
  @param:
  <ul>
    <li>
      optional ready completion which will be called after the socket is connected
    </li>
  </ul>
*/
- (void)connectToSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery readyCompletion:(void (^ _Nullable)(void))readyCompletion;
/**
  Perform reconnect to socket for conversationQuery:
  <ul>
    <li>
      Remove the websocket handler
    </li>
    <li>
      connect to socket
      @param:
    </li>
    <li>
      optional ready completion which will be called after the socket is connected
    </li>
  </ul>
*/
- (void)reconnectToSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery readyCompletion:(void (^ _Nullable)(void))readyCompletion;
/**
  Perform disconnect from socket for conversationQuery
*/
- (void)disconnectSocket:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/**
  Clear history of all closed conversations and their messages from the database.
  This method is allowed only if there is no active/open conversation.
*/
- (BOOL)clearHistory:(id <ConversationParamProtocol> _Nonnull)conversationQuery;
/**
  Delete all conversations and their messages from the database, which older than X months.
  The number of months allowed is defined in LPConfig with attribute: deleteClosedConversationOlderThanMonths
*/
- (void)deleteOldConversations;
/**
  Set AMSManagerDelegate implementor
*/
- (void)setDelegate:(id <AMSManagerDelegate> _Nonnull)delegate;
/**
  Remove AMSManagerDelegate implementor
*/
- (void)removeDelegate;
/**
  Initialize new AMS Handler related paired with conversation.
*/
- (void)initializeConversation:(LPConversationEntity * _Nonnull)conversation SWIFT_METHOD_FAMILY(none);
/**
  Create new AMSConversationHandler and attach it as delegate to its corresponding Web Socket Handler
*/
- (void)setupConversation:(LPConversationEntity * _Nonnull)conversation;
/**
  Create new conversation instance
*/
- (LPConversationEntity * _Nonnull)createConversation:(LPBrandEntity * _Nonnull)brand;
/**
  Send message from a Message instance related to an owner conversation
*/
- (void)sendMessageInConversation:(LPConversationEntity * _Nonnull)conversation message:(LPMessageEntity * _Nonnull)message completion:(void (^ _Nonnull)(LPMessageEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/**
  Send message from a text string related to an owner conversation
  This method will create new Message instance in the database.
  Messages might be masked depending on regex and masking from LPConfig
*/
- (void)sendMessageInConversation:(LPConversationEntity * _Nonnull)conversation text:(NSString * _Nonnull)text completion:(void (^ _Nonnull)(LPMessageEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/**
  Resolve/End a conversation from the user side
*/
- (void)resolveConversation:(LPConversationEntity * _Nonnull)conversation;
/**
  Request to change the conversation urgency status to on/off
*/
- (BOOL)requestUrgentResponse:(LPConversationEntity * _Nonnull)conversation urgent:(BOOL)urgent;
/**
  Retreive new messages from server for an owner converation
*/
- (void)retrieveNewMessagesForConversation:(LPConversationEntity * _Nonnull)conversation completion:(void (^ _Nullable)(void))completion failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/**
  Submit CSAT to the server for an owner conversation
  CSAT model is based on: rate of the csat, resolutionConfirmation toggle and wether csat is skipped or not
*/
- (void)sendCSATRate:(LPConversationEntity * _Nonnull)conversation csat:(CSATModel * _Nonnull)csat;
/**
  Clear all properties and data of the manager
*/
- (void)clearManager;
@end

typedef SWIFT_ENUM(NSInteger, Features) {
  FeaturesPhotoSharing = 0,
};

@class Ring;

@interface AMSManager (SWIFT_EXTENSION(LPAMS))
- (void)takeConversation:(Ring * _Nonnull)ring agentToken:(NSString * _Nonnull)agentToken completion:(void (^ _Nonnull)(LPConversationEntity * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
- (void)backToQueue:(NSString * _Nonnull)userID conversation:(LPConversationEntity * _Nonnull)conversation;
- (void)subscribeAgentState:(NSString * _Nonnull)agentID conversation:(LPConversationEntity * _Nonnull)conversation;
- (void)setAgentState:(NSString * _Nonnull)agentUserId channels:(NSArray<NSString *> * _Nonnull)channels availability:(NSString * _Nonnull)availability description:(NSString * _Nonnull)description conversation:(LPConversationEntity * _Nonnull)conversation;
- (void)agentRequestConversation:(NSDictionary<NSString *, NSString *> * _Nonnull)context ttrDefName:(NSString * _Nonnull)ttrDefName channelType:(NSString * _Nonnull)channelType consumerId:(NSString * _Nonnull)consumerId conversation:(LPConversationEntity * _Nonnull)conversation;
- (NSArray<NSString *> * _Nonnull)getAllConsumersID;
- (NSDictionary<NSString *, NSArray<LPConversationEntity *> *> * _Nonnull)getConversationsByConsumers;
@end

@class UIImage;

@interface AMSManager (SWIFT_EXTENSION(LPAMS))
/**
  Sends a new messge with file from gallery or camera
*/
- (void)uploadFileFromImageInfoWithImageInfo:(NSDictionary<NSString *, id> * _Nonnull)imageInfo caption:(NSString * _Nonnull)caption conversation:(LPConversationEntity * _Null_unspecified)conversation completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/**
  Uploading file that is saved on disk (mainly for failed messages)
*/
- (void)uploadFileFromDiskWithMessage:(LPMessageEntity * _Nonnull)message conversation:(LPConversationEntity * _Nonnull)conversation completion:(void (^ _Nonnull)(void))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
/**
  Downloads a file from Swift server and returns an image to show
*/
- (void)downloadFileWithConversation:(LPConversationEntity * _Nonnull)conversation file:(LPFileEntity * _Nonnull)file completion:(void (^ _Nonnull)(UIImage * _Nonnull))completion failure:(void (^ _Nonnull)(NSError * _Nonnull))failure;
@end


@interface AMSManager (SWIFT_EXTENSION(LPAMS))
/**
  Perform server request for unsubscribe exConversation
*/
- (void)unsubscribeConversationDetails:(NSString * _Nonnull)brandID subscriptionID:(NSString * _Nonnull)subscriptionID;
- (void)saveSubscriptionID:(NSString * _Nonnull)subscriptionID brandID:(NSString * _Nonnull)brandID;
- (NSString * _Nullable)getSubscriptionID:(NSString * _Nonnull)brandID;
- (void)removeSubscription:(NSString * _Nonnull)brandID;
- (void)removeSubscriptions;
/**
  \code
     Save the last subscription time of a brand in order to get from now on only new changes

  \endcode*/
- (void)saveSubscriptionTime:(NSDate * _Nonnull)time brandID:(NSString * _Nonnull)brandID;
/**
  Archive subcription times in NSUserDefaults in order to load it for next subscription.
  We perform the archive after a delay of 20.0 seconds and cacnel all the archive request in this interval in order to prevent over-flow of archeiving
*/
- (void)archiveSubscriptionTime:(BOOL)forceArchive;
- (void)sendGetClock:(NSString * _Nonnull)brandID completion:(void (^ _Nullable)(int64_t))completion;
- (void)saveClockDiff:(int64_t)clockDiff brandID:(NSString * _Nonnull)brandID;
- (NSString * _Nullable)getBrandIDForSubscriptionID:(NSString * _Nonnull)subscriptionID;
@end


@interface AMSManager (SWIFT_EXTENSION(LPAMS))
- (BOOL)shouldDisplayLocalNotificationForConversation:(LPConversationEntity * _Nonnull)conversation;
- (BOOL)isBrandReady:(NSString * _Nonnull)brandID;
/**
  Determines whether history query messages already fecthced
*/
- (BOOL)didFetchHistoryQueryMessages;
/**
  Determines whether history query messages is now being fetched
*/
- (BOOL)isFetchingHistoryQueryMessages;
/**
  Determines the name of the assigned agent that should be presented in UI areas.
  If assigned agent exists and has a nickname - return it. Otherwise, return empty string.
  If the empty string is returned, it should be handled according to UI area
*/
- (NSString * _Nonnull)agentNameUIRepresentation:(LPConversationEntity * _Nullable)conversation;
/**
  Create resolved system message for conversation, according to resolving side
  Timestamp - when agent resolved we take the timestamp from server, when consumer resolved we take now.
*/
- (LPMessageEntity * _Nullable)createResolveLocalMessage:(LPConversationEntity * _Nonnull)conversation isAgentSide:(BOOL)isAgentSide endTime:(NSDate * _Nonnull)endTime;
/**
  Creates local system message for masked message according to the current masking type:
  RealTime or ClientOnly masking.
  Return value - local masked message, nil if failed
*/
- (LPMessageEntity * _Nullable)createMessageMaskedLocalMessage:(LPConversationEntity * _Nonnull)conversation;
/**
  Get client properties to be sent to AMS using predefiend AMS parameters.
  This method is used for sending information to AMS
*/
+ (NSString * _Nonnull)clientPropertiesString;
@end

@class TTRModel;

SWIFT_PROTOCOL("_TtP5LPAMS18AMSManagerDelegate_")
@protocol AMSManagerDelegate
- (void)didSendMessages:(LPConversationEntity * _Nonnull)conversation messages:(NSArray<LPMessageEntity *> * _Nonnull)messages;
- (void)didReceiveMessages:(LPConversationEntity * _Nonnull)conversation messages:(NSArray<LPMessageEntity *> * _Nonnull)messages;
- (void)resolveConvesationDidFail:(LPConversationEntity * _Nonnull)conversation error:(NSError * _Nonnull)error;
- (void)resolveConvesationRequestDidFinish:(LPConversationEntity * _Nonnull)conversation;
- (void)conversationDidResolve:(LPConversationEntity * _Nonnull)conversation;
- (void)newConversationCreated:(LPConversationEntity * _Nonnull)conversation;
- (void)urgentRequestDidFail:(LPConversationEntity * _Nonnull)conversation error:(NSError * _Nonnull)error;
- (void)chatStateChanged:(LPConversationEntity * _Nonnull)conversation state:(NSString * _Nonnull)state;
- (void)didChangeMessagesStatus:(LPConversationEntity * _Nonnull)conversation messages:(NSArray<LPMessageEntity *> * _Nonnull)messages;
- (BOOL)isConversationRelatedToViewController:(LPConversationEntity * _Nonnull)conversation;
- (void)conversationInitializedOnAMS:(LPConversationEntity * _Nonnull)conversation;
@optional
- (void)didReceiveTTRUpdate:(LPConversationEntity * _Nonnull)conversation ttr:(TTRModel * _Nonnull)ttr;
- (void)didUpdateProfile:(LPConversationEntity * _Nonnull)conversation userId:(NSString * _Nonnull)userId;
- (void)csatScoreSubmissionDidFinish:(LPConversationEntity * _Nonnull)conversation csat:(CSATModel * _Nonnull)csat;
- (void)csatScoreSubmissionDidFail:(LPConversationEntity * _Nonnull)conversation error:(NSError * _Nonnull)error;
@required
- (BOOL)isConversationVisible;
- (NSString * _Nullable)brandAccountID;
- (void)didReceiveRingUpdate:(NSString * _Nonnull)conversationID ring:(Ring * _Nonnull)ring;
- (void)sdkFeatureToggledWithFeature:(enum Features)feature toggle:(BOOL)toggle;
@end


SWIFT_CLASS("_TtC5LPAMS14AMSRestHandler")
@interface AMSRestHandler : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class NSPredicate;

SWIFT_CLASS("_TtC5LPAMS22ConversationDataSource")
@interface ConversationDataSource : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ConversationDataSource * _Nonnull instance;)
+ (ConversationDataSource * _Nonnull)instance;
- (NSArray<LPMessageEntity *> * _Nullable)getLatestMessages:(id <ConversationParamProtocol> _Nonnull)query;
- (NSArray<LPMessageEntity *> * _Nonnull)getMessagesFromConversationWithConversation:(LPConversationEntity * _Nonnull)conversation;
/**
  Get next conversation which messages need to query.
  Calculating of next conversation is done by gathering all the conversations that needs to be queried, and the one with the latest creationDate
*/
- (LPConversationEntity * _Nullable)getNextConversationForQueryMessagesIfExists:(id <ConversationParamProtocol> _Nonnull)query;
/**
  \code
     Get all conversations per query and params.
     - QueryParamProtocol: protocol of the current requested type

  \endcode*/
- (NSArray<LPConversationEntity *> * _Nullable)getConversations:(id <ConversationParamProtocol> _Nonnull)query predicate:(NSPredicate * _Nullable)predicate;
/**
  Get all active conversations per query and params.
  <ul>
    <li>
      QueryParamProtocol: protocol of the current requested type
    </li>
  </ul>
*/
- (LPConversationEntity * _Nullable)getActiveConversation:(id <ConversationParamProtocol> _Nonnull)query;
/**
  Get the newest (latest) close conversation if exists
  <ul>
    <li>
      QueryParamProtocol: protocol of the current requested type
    </li>
  </ul>
*/
- (NSArray<LPConversationEntity *> * _Nullable)getLatestClosedConversations:(id <ConversationParamProtocol> _Nonnull)query conversationsCount:(NSInteger)conversationsCount;
- (LPConversationEntity * _Nonnull)createConversation:(id <ConversationParamProtocol> _Nonnull)query;
/**
  Clear a dummy conversation and its assoicated messages.
  A dummy conversation is a conversation which is created and now only shows welcome message
  Before removing the conversation, we are checking that there is no multiple messages which are still not sent to prevent cases when new conversation with messages still not synced with server and may be deleted
*/
- (BOOL)clearDummyConversation:(LPConversationEntity * _Nonnull)conversation;
/**
  Get the assigned agent of the recent open/closed conversation if exists.
*/
- (LPUserEntity * _Nullable)getAssignedAgent:(id <ConversationParamProtocol> _Nonnull)query;
@end

#pragma clang diagnostic pop
